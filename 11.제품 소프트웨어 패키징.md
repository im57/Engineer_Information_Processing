#### 108) 소프트웨어 패키징

 : 모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것

- 개발자가 아닌 사용자 중심

- 패키징 시 고려사항

  - 사용자의 시스템 환경에 필요한 최소 환경 정의
  - 소프트웨어는 단순히 패키징하여 배포하는 것으로 끝나는 것이 아니라 하드웨어와 함께 관리될 수 있도록 Managed Service 형태로 제공
  - 고객의 편의성을 고려한 안정적인 배포 중요
  - 다양한 사용자의 요구사항을 반영할 수 있도록 패킹징의 변경 및 개선에 대한 관리 항상 고려

- 패키징 작업 순서

  - 프로젝트 개발 과정에서 주기별로 패키징한 결과물은 테스트 서버에 배포

  - 마지막 개발 과정을 거쳐 최종 패키징한 결과물은 고객이 사용할 수 있도록 온라인 또는 오프라인으로 배포

    - 온라인 배포

      : 별도로 마련한 운영 서버에 설치 및 사용 메뉴얼과 함께 배포 파일을 등록하여 고객이 직접 다운받아 사용

    - 오프라인 배포

      : CD-ROM이나 DVD, USB 등에 설치 및 사용 메뉴얼과 함께 배포 파일을 담음

  - 순서

    - 기능 식별

      : 작성된 코드의 기능 확인

    - 모듈화

      : 확인된 기능 단위로 코드 분류

    - 빌드 진행

      : 모듈 단위별로 실행 파일 만들기

    - 사용자 환경 분석

      : 웹, 모바일 등 소프트웨어가 사용될 환경이나 운영체제, CPU 등의 최소 운영 환경 정의

    - 패키징 및 적용 시험

      + 빌드된 실행 파일들을 정의된 환경에 맞게 배포용 파일 형식으로 패키징

      - 정의된 환경과 동일한 환경에서 패키징 결과를 테스팅한 후 소프트웨어에 대한 불편사항을 사용자 입장에서 확인

    - 패키징 변경 개선

      : 확인된 불편 사항을 반영하기 위한 패키징의 변경 및 개선 진행

    - 배포

      : 배포 수행 시 오류가 발생하면 해당 개발자에게 전달하여 수정 요청





#### 109) 릴리즈 노트 작성

 : 개발 과정에서 정리된 릴리즈 정보를 소프트웨어의 최종 사용자인 고객과 공유하기 위한 문서

- 테스트 진행 방법에 대한 결과와 소프트웨어 사양에 대한 개발팀의 정확한 준수 여부 확인 가능

- 소프트웨어에 포함된 전체 기능, 서비스 내용, 개선 사항 등을 사용자와 공유 가능

- 소프트웨어의 버전 관리나 릴리즈 정보를 체계적으로 관리 가능

- 릴리즈 노트 초기 버전 작성 시 고려사항

  - 릴리즈는 정확하고 완전한 정보를 기반으로 개발팀에서 직접 현재 시제로 작성

  - 신규 소스, 빌드 등의 이력이 정확하게 관리되어 변경 또는 개선된 항목에 대한 이력 정보들도 작성

  - 일반적으로 다음 항목 포함

    - Header

      : 릴리즈 노트 이름, 소프트웨어 이름, 릴리즈 버전, 릴리즈 노트 날짜, 릴리즈 노트 버전 등

    - 개요

      : 소프트웨어 및 변경사항 전체에 대한 간략한 내용

    - 목적

      : 해당 릴리즈 버전에서의 새로운 기능이나 수정된 기능의 목록과 릴리즈 노트의 목적에 대한 간략한 개요

    - 문제 요약, 재현 항목, 수정/개선 내용, 사용자 영향도, SW 지원 영향도, 노트, 면책조항, 연락처

- 릴리즈 노트 추가 버전 작성 시 고려 사항

  - 중대한 오류가 발생하여 긴급하게 수정하는 경우에 릴리즈 버전을 출시하고 버그 번호를 포함한 모든 수정된 내용을 담아 릴리즈 노트 작성
  - 소프트웨어에 대한 기능 업그레이드를 완료한 경우에 릴리즈 버전을 출시하고 릴리즈 노트 작성
  - 사용자로부터 접수된 요구사항에 의해 추가나 수정된 경우 자체 기능 향상과는 다른 별도의 릴리즈 노트 작성

- 릴리즈 노트 작성 순서

  - 모듈 식별

    : 모듈 별 빌드 수행 후 릴리즈 노트에 작성될 내용 확인

  - 릴리즈 정보 확인

    : 릴리즈 노트 이름, 소프트웨어 이름, 릴리즈 버전, 릴리즈 날짜, 노트 날짜, 노트 버전 등 확인

  - 릴리즈 노트 개요 작성

    : 소프트웨어 및 변경 사항 전체에 대한 간략한 내용 작성

  - 영향도 체크

    : 버그나 이슈 관련 내용 또는 해당 릴리즈 버전에서의 기능 변화가 다른 소프트웨어나 기능을 사용하는데 미칠 수 있는 영향 기술

  - 정식 릴리즈 노트 작성

    : 헤더, 개요, 영향도 체크 항목을 포함하여 정식 릴리즈 노트에 작성될 기본 사항 작성

  - 추가 개선 항목 식별

    : 추가 버전 릴리즈 노트 작성이 필요한 경우 추가 릴리즈 노트 작성





#### 110) 디지털 저작권 관리(DRM)

 : 저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록 디지털 콘텐츠의 생성, 유통, 이용까지의 전 과정에 걸쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술

- 저작권

  : 창작가가 가지는 배타적 독점적 권리로 타인의 침해를 받지 않을 고유한 권한

- 원본 콘텐츠가 아날로그인 경우 디지털로 변환한 후 패키저에 의해 DRM 패키징 수행

- 콘텐츠 크기가 작을 경우 사용자가 콘텐츠를 요청하는 시점에서 실시간으로 패키징을 수행하고, 크기가 큰 경우에는 미리 패키징을 수행한 후 배포

- 패키징을 수행하면 콘텐츠에는 암호화된 저작권자의 전자서명이 포함되고 저작권자가 설정한 라이선스 정보가 클리어링 하우스에 등록

- 콘텐츠를 사용하기 위해서는 클리어링 하우스에 등록된 라이선스 정보를 통해 사용자 인증과 콘텐츠 사용 권한 소유 여부를 확인받아야 함

- 흐름도

  - 콘텐츠 제공자는 클리어링 하우스에 라이선스 등록

  - 클리어링 하우스는 콘텐츠 소비자에 라이선스 발급

  - 콘텐츠 소비자는 클리어링 하우스에 요금 지불

  - 콘텐츠 제공자는 콘텐츠 분배자에 콘텐츠 등록

  - 콘텐츠 소비자는 콘텐츠 분배자에 라이선스 요청

  - 콘텐츠 분배자는 클리어링 하우스에 라이선스 요청

  - 콘텐츠 분배자는 콘텐츠 소비자에 콘텐츠 다운로드

  - 클리어링 하우스

    : 저작권에 대한 사용 권한, 라이선스 발급, 사용량에 따른 결제 관리 등 수행

  - 콘텐츠 제공자

    : 콘텐츠를 제공하는 저작권자

  - 패키저

    : 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화 하는 프로그램

  - 콘텐츠 분배자

    : 암호화된 콘텐츠를 유통하는 곳이나 사람

  - 콘텐츠 소비자

    : 콘텐츠를 구매해서 사용하는 주체

  - DRM 컨트롤러

    : 배포된 콘텐츠의 이용 권한을 통제하는 프로그램

  - 보안 컨테이너

    : 콘텐츠의 원본을 안전하게 유통하기 위한 전자적 보안 장치

- 기술요소

  - 암호화

    : 콘텐츠 및 라이선스를 암호화하고 전자서명

  - 키 관리

    : 콘텐츠를 암호화한 키에 대한 저장 및 분배

  - 암호화 파일 생성

    : 콘텐츠를 암호화된 콘텐츠로 생성

  - 식별 기술

    : 콘텐츠에 대한 식별 체계 표현

  - 저작권 표현

    : 라이선스의 내용 표현

  - 정책 관리

    : 라이선스 발급 및 사용에 대한 정책 표현 및 관리

  - 크랙 방지

    : 크랙에 의한 콘텐츠 사용 방지

  - 인증

    : 라이선스 발급 및 사용의 기준이 되는 사용자 인증





#### 111) 소프트웨어 설치 메뉴얼 작성

- 소프트웨어 설치 메뉴얼

  : 개발 초기부터 적용된 기준이나 사용자가 소프트웨어를 설치하는 과정에 필요한 내용을 기록한 설명서와 안내서

  - 사용자 기준으로 작성

  - 설치 시작부터 완료할 때까지의 전 과정을 빠짐없이 순서대로 설명

  - 서문

    - 문서이력

    - 설치 메뉴얼의 주석

      - 주의사항

        : 사용자가 반드시 알고 있어야 하는 중요한 내용 기술

      - 참고사항

        : 설치에 영향을 미칠 수 있는 사용자의 환경이나 상황에 대한 내용 기술

    - 설치 도구의 구성

      - exe, dll 등의 설치 관련 파일에 대해 설명
      - 폴더 및 설치 프로그램 실행 파일에 대해 설명
      - 설치 과정 및 결과가 기록되는 log 폴더에 대해 설명

    - 설치 환경 체크 항목 기술

      - 사용자 환경, 응용 프로그램, 업그레이드 버전, 백업 폴더 확인

  - 기본 사항

    - 소프트웨어 개요

      : 소프트웨어 주요 기능 및 UI 설명

    - 설치 관련 파일

      : 소프트웨어 설치에 필요한 파일 설명

    - 설치 아이콘

    - 프로그램 삭제

      : 설치된 소프트웨어 삭제 방법 설명

    - 관련 추가 정보

      - 소프트웨어 이외의 관련 설치 프로그램 정보
      - 소프트웨어 제작사 등의 추가 정보 기술

  - 설치 메뉴얼 작성 방법

    : 사용자가 설치 과정을 이해하기 쉽도록 설치 화면을 누락 없이 캡쳐하고 순서대로 상세히 설명

    - 설치 화면 및 UI
    - 설치 이상 메세지 설명
    - 설치 완료 및 결과
    - FAQ
    - 설치 시 점검 사항
    - Network 환경 및 보안
    - 고객 지원 방법
    - 준수 정보 & 제한 보증

  - 설치 메뉴얼  작성 순서

    - 기능 식별

      : 소프트웨어 개발 목적과 주요 기능을 흐름 순으로 정리하여 기록

    - UI 분류

      : 설치 메뉴얼을 작성할 순서대로 UI 분류 후 기록

    - 설치 파일 / 백업 파일 확인

      : 폴더 위치, 설치 파일, 백업 파일 등의 개별적 기능 확인하여 기록

    - Uninstall 절차 확인

      : 직접 Uninstall을 수행하며 그 순서를 단계별로 자세히 기록

    - 이상 case 확인

      : 설치 과정에서 발생할 수 있는 다양한 case를 만들어 확인하고 해당 case에 대한 대처법을 자세하게 기록

    - 최종 메뉴얼 적용

      - 설치가 완료된 화면과 메세지를 캡쳐하여 추가
      - 완성된 매뉴얼을 검토하고 고객 지원에 대한 내용 기록





#### 112) 소프트웨어 사용자 메뉴얼 작성

 : 사용자가 소프트웨어를 사용하는 과정에서 필요한 내용을 문서로 기록한 설명서와 안내서

- 사용자가 소프트웨어 사용에 필요한 절차, 환경 등의 제반 사항이 모두 포함되도록 작성

- 소프트웨어 배포 후 발생될 수 있는 오류에 대한 패치나 기능에 대한 업그레이드를 위해 메뉴얼의 버전 관리

- 개별적으로 동작 가능한 컴포넌트 단위로 메뉴얼 작성

- 컴포넌트 명세서와 컴포넌트 구현 설계서를 토대로 작성

- 서문

  - 문서이력

  - 사용자 메뉴얼의 주석

    - 주의사항

      : 사용자가 반드시 알고 있어야 하는 중요한 내용 기술

    - 참고사항

      : 설치에 영향을 미칠 수 있는 사용자의 환경이나 상황에 대한 내용 기술

  - 기록 보관 내용

    - 소프트웨어를 사용하면서 필요한 기술 지원이나 추가 정보를 얻기 위한 소프트웨어 등록 정보 기술

- 기본 사항

  - 소프트웨어 개요

    : 소프트웨어 주요 기능 및 UI 설명

  - 소프트웨어 사용 환경

    : 소프트웨어 사용을 위한 최소 환경 설명

  - 소프트웨어 관리

    : 소프트웨어의 사용 종료 및 관리 등에 관한 내용 설명

  - 모델, 버전별 특징

    : 모델 및 버전 별로 UI 및 기능의 차이점 요약

  - 기능, 인터페이스 특징

  - 소프트웨어 구동 환경

- 사용자 메뉴얼 작성 방법

  : 사용자가 사용 방법을 이해하기 쉽도록 상황별로 누락 없이 캡처하여 순서대로 상세히 설명

  - 사용자 화면 및 UI
  - 주요 기능 분류
  - 응용 프로그램 및 설정
  - 장치 연동
  - Network 환경
  - Profile 안내
  - 고객지원방법
  - 준수 정보 & 제한 보증

- 사용자 메뉴얼 작성 순서

  - 기능 식별

    : 소프트웨어의 개발 목적과 사용자 활용 기능을 흐름 순으로 정리하여 기록

  - 사용자 화면 분류

    : 사용자 화면을 메뉴별로 분류하여 기록

  - 사용자 환경 파일 확인

    : 폴더 위치, 사용자 로그 파일, 백업 파일 등의 개별적 기능을 확인하여 기록

  - 초기화 절차 확인

    : 프로그램을 사용하기 위한 초기화 절차를 확인하고 그 단계를 순서대로 기록

  - 이상 case 확인

    : 소프트웨어 사용 과정에서 발생할 수 있는 다양한 이상 cas를 만들어 확인하고 해당 case에 대한 대처법 자세히 기록

  - 최종 메뉴얼 적용

    - 사용과 관련된 문의 답변 정리하여 기록
    - 완성된 메뉴얼을 검토하고 고객 지원에 대한 내용 기록





#### 113) 소프트웨어 버전 등록

- 형상 관리

  : 소프트웨어의 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동

  - 개발 전 단꼐에 적용되는 활동이며, 유지 보수 단계에서도 수행

  - 소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해요인이 최소화되도록 보증하는 것을 목적

  - 중요성

    - 지속적인 소프트웨어 변경 사항을 체계적으로 추적하고 통제 가능
    - 제품 소프트웨어에 대한 무절제한 변경 방지
    - 제품 소프트웨어에서 발견된 버그나 수정 사항 추적 가능
    - 진행 정도 확인 기준으로 사용

  - 형상 관리 기능

    - 형상 식별

      : 형상 관리 대상에 이름과 관리 번호를 부여하고, 계층 구조로 구분하여 수정 및 추적이 용이하도록 하는 작업

    - 버전 제어

      : 소프트웨어 업그레이드나 유지 보수 과정에서 생성된 다른 버전의 형상 항목을 관리하고, 이를 위해 특정 절차와 도구 결합시키는 작업

    - 형상 통제

      : 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선이 잘 반영될 수 있도록 조정하는 작업

    - 형상 감사

      : 기준의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업

    - 형상 기록

      : 형상의 식별, 통제, 감사 작업의 결과를 기록, 관리 하고 보고서 작성하는 작업

  - 소프트웨어 버전 등록 관련 주요 용어

    - 저장소 (repository)

      : 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장되어 있는 곳

    - 가져오기 (import)

      : 버전 관리가 되고 있지 않은 아무것도 없는 저장소에 처음으로 파일 복사

    - 체크아웃

      : 프로그램을 수정하기 위해 저장소에서 파일 받아옴

    - 체크인

      : 체크아웃한 파일의 수정을 완료한 후 저장소의 파일을 새로운 버전으로 갱신

    - 커밋

      : 체크인을 수행할 때 이전에 갱신된 내용이 있는 경우 충돌을 알리고 수정한 후 갱신 완료

    - 동기화 (Update)

      : 저장소에 있는 최신 버전으로 자신의 작업 공간 동기화

  - 소프트웨어 버전 등록 과정

    - 가져오기 (import)

      : 개발자가 저장소에 신규로 파일 추가

    - 인출 (check-out)

      : 수정 작업을 진행할 개발자가 저장소에 추가된 파일을 자신의 작업 공간으로 인출

    - 예치 (commit)

      : 인출할 파일을 수정한 후 설명을 붙여 저장소에 예치

    - 동기화 (update)

      : 커밋 후 새로운 개발자가 자신의 작업 공간을 동기화

      - 이때 기존 개발자가 추가한 파일이 전달

    - 차이 (diff)

      : 새로운 개발자가 추가된 파일의 수정 기록을 확인하면서 이전 개발자가 처음 추가한 파일과 이후 변경된 파일의 차이 확인





#### 114) 소프트웨어 버전 관리 도구

- 공유 폴더 방식

  : 버전 관리 자료가 로컬 컴퓨터의 공유 폴더에 저장되어 관리되는 방식

  - 개발자들이 개발이 완료된 파일을 약속된 공유 폴더에 매일 복사

  - 파일을 잘못 복사하거나 다른 위치로 복사하는것에 대비하기 위해 파일 변경 사항을 데이터베이스에 기록하여 관리

    ex) SCCS, RCS, PVCS, QVCS 등

- 클라이언트/서버방식

  : 버전 관리 자료가 중앙 시스템에 저장되어 관리되는 방식

  - 서버의 자료를 개발자별로 자신의 PC로 복사하여 작업한 후 변경 내용을 서버에 반영

  - 모든 버전 관리는 서버에서 수행

  - 서버에 문제 생기면 서버가 복구되기 전까지 다른 개발자와의 협업 및 버전 관리 작업 중단

    ex) CVS, SVN, SVSNT, Clear Case, CMVC, Perforce 등

- 분산 저장소 방식

  : 버전 관리 자료가 하나의 원격 저장소와 분산된 개발자 pc의 로컬 저장소에 함께 저장되어 관리되는 방식

  - 개발자별로 원격 저장소의 자료를 자신의 로컬 저장소로 복사하여 작업한 후 변경된 내용을 로컬 저장소에서 우선 반영한 후 이를 원격 저장소에 반영

  - 원격 저장소에 문제가 생겨도 로컬 저장소의 자료를 이용해 작업 가능

    ex) GIT, GNU arch, DCVS 등

- Subversion (SVN)

  - 클라이언트/서버 구조로, 서버에는 최신 버전의 파일들과 변경 내역 관리

  - 서버의 자료를 복사해와 작업한 후 변경 내용을 서버에 반영

  - 모든 개발 작업은 trunk 디렉터리에서 수행되며 추가 작업은 branches 디렉터리 안에 별도의 디렉터리를 만들어 작업을 완료한 후 trunk 디렉터리와 병합

  - 커밋할 때마다 revision이 1증가

  - 소스가 오픈되어 있어 무료로 사용 가능

  - 파일이나 디렉터리의 이름 변경, 이동 등 가능

  - 명령어

    - add

      : 새로운 파일이나 디렉터리를 버전 관리 대상으로 등록

    - commit

      : 버전 관리 대상으로 등록된 클라이언트의 소스 파일을 서버의 소스파일에 적용

    - update

      : 서버의 최신 commit 이력을 클라이언트의 소스 파일에 적용

    - checkout

      : 버전 관리 정보와 소스 파일을 서버에서 클라이언트로 받아옴

    - lock/unlock

      : 서버의 소스파일이나 디렉터리를 잠그거나 해제

    - import

      : 아무것도 없는 서버의 저장소에 맨 처음 소스파일을 저장

    - export

      : 버전 관리 정보를 제외한 순수한 소스 파일만 서버에서 받아옴

    - info

      : 지정한 파일에 대한 위치나 마지막 수정 일장 등에 대한 정보 표시

    - diff

      : 지정한 파일이나 경로에 대해 이전 리비전과의 차이 표시

    - merge

      : 다른 디렉터리에서 작업된 버전 관리 내역을 기본 개발 작업과 병합

- GIT

  : 리누스 토발즈가 2005년 리눅스 커널 개발에 사용할 관리도구로 개발한 이후 주니오 하마노에 의해 유지 보수

  - 분산 버전 관리 시스템으로 2개의 저장소, 즉 로컬 저장소와 원격 저장소 존재

  - 지역 저장소는 실제 개발을 진행하는 장소로, 버전 관리가 수행됨

  - 원격 저장소는 여러 사람들이 협업을 위해 버전을 공동 관리 하는 곳으로, 자신의 버전 관리 내역을 반영하거나 다른 개발자의 변경 내용을 가져올 때 사용

  - 버전 관리가 지역 저장소에서 진행되므로 버전 관리가 신속하게 처리되고, 원격 저장소나 네트워크에 문제가 있어도 작업 가능

  - 브랜치를 이용하면 기본 버전 관리 틀에 영향을 주지 않으면서 다양한 형태의 기능 테스팅 가능

  - 파일의 변화는 스냅샷으로 저장

  - 명령어

    - add

      : 작업 내역을 지역 저장소에 저장하기 위해 스테이징 영역에 추가

    - commit

      : 작업 내역을 지역 저장소에 저장

    - branch

      : 새로운 브랜치 생성

      - --d 옵션으로 삭제

    - checkout

      : 지정 브랜치로 이동

    - merge

      : 지정 브랜치의 변경 내역을 현재 HEAD 포인터가 가리키는 브랜치에 반영함으로 두 브랜치 병합

    - init

      : 지역 저장소 생성

    - remote add

      : 원격 저장소 연결

    - push

      : 로컬 저장소의 변경내역을 원격 저장소에 반영

    - fetch

      : 원격 저장소의 변경이력만 지역 저장소로 가져와 반영

    - clone

      : 원격 저장소의 전체 내용을 지역 저장소로 복제

    - fork

      : 지정한 원격 저장소의 내용을 자신의 원격 저장소로 복제

  - 깃 명령어 활용

    - 계정 설정하기

      : 사용자 이름과 메일 등록

      ```git
      git config --global user.name "im57"
      git config --global user.email "im@gmail.com"
      ```

    - 지역 저장소 만들기

      : 버전 관리 내역이 저장될 지역 저장소 생성

      - 실제 개발 작업을 진행하는 폴더에 생성
      - .git 폴더 생성
      - 버전 관리 내역이 .git 폴더에 저장

      ```git
      git init
      ```

    - 변경 내역을 지역 저장소에 저장

      - 작업 내역을 지역 저장소에 저장하기 전에 스테이징 영역에 추가

        ```git
        git add .
        ```

      - 작업 내역을 지역 저장소에 저장

        ```git
        git commit -m "commit success"
        ```

    - 병합기능 사용하기

      - 새로운 브랜치 생성

        ```git
        git branch feature
        ```

      - 가장 최근의 commit을 가리키는 포인터를 현재 작업중인 브랜치에서 feature 브랜치로 이동

        ```git
        git checkout feature
        ```

      - 현재 작업 폴더의 변경 내역을 저장

        - 변경 내역은 feature 브랜치에 저장

        ```git
        git add .
        git commit -m "feature commit"
        ```

      - feature 브랜치의 커밋 내역을 마스터 브랜치와 병합하기 위해 포인터를 마스터로 이동

        ```git
        git checkout master
        ```

      - feature 브랜치의 커밋내역을 마스터 브랜치와 병합 후 feature 브랜치 제거

        ```git
        git merge feature
        git brance --d feature
        ```

    - 지역 저장소의 버전 관리 내역을 원격 저장소에 저장

      - 원격 저장소 연결

        ```git
        git remote add origin https://github.com/-
        ```

      - 지역 저장소의 변경 내역을 다른 개발자와 공유하기 위해 원격 저장소에 저장

        ```git
        git push origin master
        ```





#### 115) 빌드 자동화 도구

- 빌드

  : 소스 코드 파일들을 컴파일한 후 여러 개의 모듈을 묶어 실행 파일로 만드는 과정

- 빌드 자동화 도구

     : 빌드를 포함하여 테스트 및 배포를 자동화하는 도구

  ex) Ant, Make, Maven, Gradle, Jenkins 등

  - Jenkins

    :  Java 기반의 오픈 소스 형태로, 가장 많이 사용되는 빌드 자동화 도구

    - 서블릿 컨테이너에서 실행되는 서버 기반 도구
    - 대부분의 형상관리 도구와 연동 가능
    - 여러 대의 컴퓨터를 이용한 분산 빌드나 테스트 가능

  - Gradle

    : Groovy 기반으로 한 오픈 소스 형태의 자동화도구로, 안드로이드 앱 개발 환경에서 사용

    - 플러그인을 설정하면 자바, C/C++, python 등의 언어도 빌드 가능
    - Groovy를 사용해서 만든 DSL을 스크립트 언어로 사용
    - 실행할 처리 명령들을 모아 태스크로 만든 후 태스크 단위로 실행
    - 이전에 사용했던 태스크를 재사용하거나 다른 시스템의 태스크를 공유할 수 있는 빌드 캐시 기능을 지원하므로 빌드의 속도 향상 가능